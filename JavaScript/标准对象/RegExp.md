# RegExp

在 JavaScript 中创建正则表达式有两种方法：

- 直接通过/正则表达式/写出来；
- 通过 `new RegExp('正则表达式')` 创建一个RegExp对象；

举个例子，

```
var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');
```

那么如何判断正则表达式是否匹配呢？

```
var re = /^\d{3}\-\d{3,8}$/;
re.test("010-12345");
re.test("010-1234x");
re.test("010 12345");
```



## 切分字符串

用正则表达式切分字符串比用固定的字符更灵活，先看正常的切分代码：

```
'a b   c'.split(" "); // ["a", "b", "", "", "c"]
```

使用正则表达式的代码，

```
'a b   c'.split(/\s+/);
'a,b, c  d'.split(/[\s\,]+/);
'a,b;; c  d'.split(/[\,\;\s]+/);
```



## 分组

正则表达式除了可以进行匹配之外，还可以用分组的功能进行字符串的提取。举个例子，

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```
var re = /^(\d{3})-(\d{3,8})$/;
re.exec("010-12345"); // ["010-12345", "010", "12345", index: 0, input: "010-12345", groups: undefined]
re.exec("010 12345"); // null
```

- `exec()`方法在匹配成功后，会返回一个 `Array`，第一个元素（"010-12345"）是正则表达式匹配到的整个字符串，后面的字符串（"010", "12345"）表示匹配成功的子串；
- `exec()`方法在匹配失败时返回 null；

提取子串在一些场景下是很有用的，比如识别合法事件，并提取具体的子串，

```
var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30'); // ["19:05:30", "19", "05", "30", index: 0, input: "19:05:30", groups: undefined]
```

但是有时候只用正则表达式还是不够的，比如识别日期：

```
var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
```

对于`'2-30'`，`'4-31'`这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。



## 贪婪匹配

正则匹配默认是贪婪匹配，也就是尽可能匹配多的字符串。举个例子，

```
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
```

由于`\d+`采用贪婪匹配，直接把后面的`0`全部匹配了，结果`0*`只能匹配空字符串了。

必须让`\d+`采用非贪婪匹配（也就是尽可能少匹配），才能把后面的`0`匹配出来，加个`?`就可以让`\d+`采用非贪婪匹配：

```
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
```

